<!DOCTYPE html>
<html>
  <body>
    <div id="root"></div>
  </body>
  <script src="https://unpkg.com/react@18.3.1/umd/react.production.min.js"></script>
  <!-- import React (엔진)-->
  <script src="https://unpkg.com/react-dom@18.3.1/umd/react-dom.production.min.js"></script>
  <!-- import React-dom (보여줘)-->
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <!-- import Babel (JSX 해석기) -->
  <script type="text/babel">
    // JSX 코드는 반드시 type="text/babel"
    const root = document.getElementById("root");
    /*
    function Title() {
      return (
        <h3 id="title" onMouseEnter={() => console.log("mouse enter")}>
          Hello I'm a title
        </h3>
      );
    } // JSX 사용 시 HTML과 유사한 문법 사용하여 간단함
    */
    /*
    const h3 = React.createElement("h3", {
        onMouseEnter: () => console.log("mouse enter"), // on붙은거 == eventlistner
    }, "Hello I am a span"); // (HTML태그, 속성, 내용)
    */
    /*
    const Button = () => (
      //() = >로 화살표 함수 만들기
      <button
        style={{ backgroundColor: "tomato" }} // 첫 번째 중괄호는 JSX 문법에서 JavaScript 표현식을 쓰겠다는 의미. 두 번째 중괄호는 스타일 객체를 작성하는 것
        onClick={() => console.log("im clicked")}
      >
        Click me
      </button>
    );
    */
    /*
    const btn = React.createElement(
      "button",
      {
        onClick: () => console.log("im clicked"),
      },
      "Click me"
    );
    */
    /*
    let counter = 0;
    function countUp() {
      counter = counter + 1;
      render(); //rerender ther Container
    }
    function render() {
      //ReactDOM.render(<Container />, root); //rerender ther Container
    }
    */
    function App() {
      const [counter, setCounter] = React.useState(0); // destructuring assignment(구조 분해 할당)
      const onClick = () => {
        setCounter(counter + 1);
      };
      return (
        <div>
          <h3>Total clicks: {counter}</h3>
          <button
            // style={{ backgroundColor: "tomato" }} // 첫 번째 중괄호는 JSX 문법에서 JavaScript 표현식을 쓰겠다는 의미. 두 번째 중괄호는 스타일 객체를 작성하는 것
            // onClick={countUp} // eventListner
            onClick={onClick}
          >
            Click me
          </button>
        </div>
      );
    }
    // const container = React.createElement("div", null, [Title, Button]);
    ReactDOM.render(<App />, root); // Container을 root안에 render(보여줘라)
  </script>
</html>

<!--
vanilla js에서는 html을 먼저 만들고, 그걸 js로 가져와서 html을 수정
react js에서는 모든 것이 js로 시작해서 html이 됨
-> react js가 element 생성 
-> react js가 element를 업데이트할 것
-> react js는 유저에게 보여질 내용을 컨트롤할 수 있음

** 브라우저가 JSX를 이해하지 못하므로 
바벨을 통해 JSX 형태의 코드를 기존의 create Element형식으로 변환해야함

** 컴포넌트의 첫 글자는 반드시 대문자 (Title, Button 등)
ex) button이라면 HTML이 됨

** state는 데이터가 저장되는 곳

** Vanilla JavaScript와 ReactJS 노드 변경 처리 과정

1. Vanilla JavaScript
Vanilla JavaScript에서는 DOM 변경을 직접 처리
필요한 DOM 요소를 직접 선택하고, 요소의 속성을 변경하거나 새로운 요소를 추가하거나 기존 요소를 제거하는 등의 작업을 직접 수행
DOM 변경이 발생하면, 브라우저는 변경된 DOM 트리를 다시 계산하고, 렌더 트리를 다시 생성한 후 화면에 그림
이 과정은 비용이 많이 드는 연산으로, 자주 발생하게 되면 성능 저하

2. ReactJS
ReactJS는 DOM 변경을 처리하기 위해 가상 DOM(Virtual DOM)이라는 개념을 도입
먼저 메모리에 가상 DOM 트리를 생성
이 트리는 실제 DOM 트리의 사본으로, 실제 DOM 트리와 별도로 존재
ReactJS는 상태 변경이 발생할 때마다 새로운 가상 DOM 트리를 생성하고, 이전의 가상 DOM 트리와 비교하여 변경된 부분을 파악
이렇게 파악된 변경 사항만 실제 DOM에 반영
=>이 과정을 '재조정(Reconciliation)' 또는 'Diffing'이라 부름
가상 DOM을 사용해 변경이 필요한 최소한의 요소만 실제 DOM에 반영되기 때문에 불필요한 연산을 줄이고 성능을 향상

결론: ReactJS는 복잡한 UI 업데이트를 효과적으로 처리할 수 있으며, 이를 통해 웹의 응답성을 향상시키고 사용자 경험을 개선할 수 있음

** React.useState() 배열에서
보통 데이터에는 counter처럼 원하는대로 붙이고
f는 set 뒤에 데이터 이름을 붙임 (setCounter)
어떤값을 부여하던 setCounter 함수는 그 값으로 업데이트하고 리렌더링 일으킴
1. counter라는 데이터를 받음
2. return()에 그 데이터를 담고 있음 (리턴은 사용자가 보게될 컴포넌트)
3. 버튼이 클릭되면 counter값을 바꿔줄 함수 호출 -> setCounter
4. counter의 새로운 값을 가지고 counter 함수를 호출
5. 그 새로운 값은 setCounter(counter + 1)에 써준 counter + 1

** const는 재할당 불가
counter의 타입은 number(원시값 타입)
컴포넌트(함수)를 렌더링하여 실행하고 나면 이 컴포넌트 함수는 종료됨
setCounter함수를 실행하면 내부에서 받은 인자값으로 useState가 리턴할 값을 업데이트하고 컴포넌트 함수를 재실행시켜서 재렌더링
컴포넌트 함수가 재실행 되면서 새로운 상수를 선언하는 것이기에 const를 사용해도 문제가 없음
값을 변경하는 동작이 없기 때문에 문제가 없는 것
-->
